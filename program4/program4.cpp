#include <iostream>
#include <thread>
#include <vector>
#include <fstream>
#include <iomanip>
#include <cstdlib>
#include <stdlib.h>
#include <assert.h>
#include <condition_variable>
#include <mutex>

using namespace std;

// Global Vars
mutex mt;
condition_variable cv;

//-!!!!!!!!!!!!!!!!!!!!!!!!!! REMEMBER TO SWITCH TO COMMAND LINE ARGS

int T = 5; // Number of threads
int R = 6; // Number of resources
int avail; // instances of resource i available

vector<int> maxn;  // maximum need of resource i for thread j
vector<int> alloc; // allocated resource i to thread j
vector<int> need;  // need of resource i for thread j
vector<int> state; // state of thread j, 0 = running, 1 = blocked, 2 = terminated

// Autogenerate
// vector<int> safeSeq;       // safeSeq[i]: thread i in safe sequence
bool isSafe();
void request(int threadId);
bool wouldBeSafe(int threadId);

// Read file stores values from requests.txt into requests vector
void readFile();
vector<vector<int>> requests;

void printVector(vector<int> v, string name);
void printVector(vector<vector<int>> v, string name);

void initializeVectors(); // if vector[i] == -1, this means thread is waiting for a request
void calcNeed(int threadId);

int main(int argc, char *argv[])
{

    // Accept command line arguments
    // if (argc < 3)
    // {
    //     cout << "Usage: " << argv[0] << " <R> <T>" << endl;
    //     return 1;
    // }
    // const char *arg1 = argv[1];
    // const char *arg2 = argv[2];
    // T = atoi(arg1);
    // R = atoi(arg2);

    // Read file requests.txt
    readFile();

    initializeVectors();
    isSafe();

    printVector(requests, "req");
    printVector(maxn, "maxn");
    printVector(alloc, "alloc");
    printVector(need, "need");

    return 0;
}

// A state is safe iff there exists a safe sequence of grants that are sufficient
// to allow all threads to eventually receive their maximum resource needs.
void request(int threadId)
{
    unique_lock<mutex> lock(mt);

    // Grant request if safe, otherwise wait
    assert(isSafe());
    while (!wouldBeSafe(threadId))
    {
        cv.wait(lock);
    }

    alloc[threadId] += 1;
    avail -= 1;
    assert(isSafe());

    // Release lock
    // lock is automatically released when unique_lock goes out of scope!!!

    // autogenerated for some reason??
    // cv.notify_all();
}

// Invariant: the system is in a safe state
bool isSafe()
{
    int toBeAvail = avail; // work is the number of available resources

    vector<bool> finish; // finish[i] = true if thread i can finish
    finish.resize(T);    // false indicates the thread cannot finish, true indicates it can

    int count = 0; // number of threads that can have finished

    while (count < T)
    {
        bool found = false;
        for (int i = 0; i < T; i++)
        {
            if (!finish[i])
            {
                // if thread i can finish
                if (need[i] <= toBeAvail)
                {
                    // release the resources from thread i
                    toBeAvail += alloc[i];

                    // mark thread i as finished
                    finish[i] = true;

                    count++;
                }
            }
            if (count == T)
        }
        if (found == false)
        {
            cout << "System is not in a safe state" << endl;
            return false;
        }
    }

    return true;
}

// Hypothetically grant request and see if resulting state is safe.
bool wouldBeSafe(int threadId)
{
    return true;
}

void calcNeed(int threadId)
{
    need[threadId] = maxn[threadId] - alloc[threadId];
}

void initializeVectors()
{
    // Initialize avail, alloc, need, and maxn
    // all threads initially have 0 resources allocated
    maxn.resize(T);
    need.resize(T);
    alloc.resize(T);
    state.resize(T);
    avail = R; // all resources are initially available
}

void readFile()
{
    ifstream inFile;
    inFile.open("requests.txt", ios::in);
    if (!inFile.is_open())
    {
        cout << "Error opening input file!" << endl;
        exit(1);
    }

    for (int i = 0; i < T; i++)
    {
        vector<int> threadVector;
        requests.push_back(threadVector);
    }

    // Read from requests.txt and write to requests vector
    vector<int> row = {-1, -1};
    while (!inFile.eof())
    {
        inFile >> row[0];
        inFile >> row[1];
        requests[row[0] - 1].push_back(row[1]);
    }

    if (row[0] == -1)
    {
        requests.pop_back();
        cout << "requests.txt was empty" << endl;
        exit(1);
    }

    inFile.close();
}

void printVector(vector<int> v, string name)
{
    cout << name << ":" << setw(6);
    for (int value : v)
        cout << value << " ";
    cout << endl;
}

void printVector(vector<vector<int>> v, string name)
{
    cout << name << ":" << endl;
    for (vector<int> row : v)
    {
        for (int value : row)
            cout << value << " ";
        cout << endl;
    }
    cout << endl;
}
