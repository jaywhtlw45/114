#include <iostream>
#include <thread>
#include <vector>
#include <fstream>
#include <iomanip>
#include <cstdlib>
#include <stdlib.h>
#include <assert.h>
#include <condition_variable>
#include <mutex>

using namespace std;

// Global Vars
mutex mt;
condition_variable cv;

//-!!!!!!!!!!!!!!!!!!!!!!!!!! REMEMBER TO SWITCH TO COMMAND LINE ARGS

int T = 5; // Number of threads
int R = 6; // Number of resources
int avail; // instances of resource i available

vector<int> maxn;  // maximum need of resource i for thread j
vector<int> alloc; // allocated resource i to thread j
vector<int> need;  // need of resource i for thread j

// Autogenerate
// vector<int> safeSeq;       // safeSeq[i]: thread i in safe sequence
bool isSafe();
void request(int threadId);
bool wouldBeSafe(int threadId);

// Read file stores values from requests.txt into requests vector
void readFile();
vector<vector<int>> requests;

void printVector(vector<int> v, string name);
void printVector(vector<vector<int>> v, string name);

void initializeVectors(); // if vector[i] == -1, this means thread is waiting for a request
void calcNeed(int threadId);

int main(int argc, char *argv[])
{

    // Accept command line arguments
    // if (argc < 3)
    // {
    //     cout << "Usage: " << argv[0] << " <R> <T>" << endl;
    //     return 1;
    // }
    // const char *arg1 = argv[1];
    // const char *arg2 = argv[2];
    // T = atoi(arg1);
    // R = atoi(arg2);

    // Read file requests.txt
    readFile();
    initializeVectors();

    printVector(requests, "req");
    printVector(maxn, "maxn");
    printVector(alloc, "alloc");
    printVector(need, "need");

    return 0;
}

// A state is safe iff there exists a safe sequence of grants that are sufficient
// to allow all threads to eventually receive their maximum resource needs.
void request(int threadId)
{
    unique_lock<mutex> lock(mt);

    // Grant request if safe, otherwise wait
    assert(isSafe());
    while (!wouldBeSafe(threadId))
    {
        cv.wait(lock);
    }

    alloc[threadId] += 1;
    avail -= 1;
    assert(isSafe());

    // autogenerated for some reason??
    // cv.notify_all();
}

// Invariant: the system is in a safe state
bool isSafe()
{
    int j;
    // vector<int> work = avail; // note this is called toBEAvail in book

    return true;
}

// Hypothetically grant request and see if resulting state is safe.
bool wouldBeSafe(int threadId)
{
    return true;
}

void calcNeed(int threadId)
{
    need[threadId] = maxn[threadId] - alloc[threadId];
}

void initializeVectors()
{
    // Initialize avail, alloc, need, and maxn
    maxn.resize(T);
    need.resize(T);
    alloc.resize(T); // all threads initially have 0 resources allocated
    avail = R;       // all resources are initially available

    maxn[0] = requests[0][1];
    cout << requests[0][1] << endl;
    for (int i = 1; i < T; i++)
        maxn[i] = -1;

    need[0] = requests[0][1];
    for (int i = 1; i < T; i++) // -1 means thread is waitning for request
        need[i] = -1;

    calcNeed(0); // Initialize need[0]
    for (int i = 1; i < T; i++)
        need[i] = -1; // -1 means thread is waiting for request
}

void readFile()
{
    ifstream inFile;
    inFile.open("requests.txt", ios::in);
    if (!inFile.is_open())
    {
        cout << "Error opening input file!" << endl;
        exit(1);
    }

    vector<int> row; // row[0] = threadId, row[1] = maxn
    row.resize(2);

    // Read from requests.txt and write to requests vector
    while (!inFile.eof())
    {
        inFile >> row[0];
        inFile >> row[1];
        requests.push_back(row);
    }
    inFile.close();
}

void printVector(vector<int> v, string name)
{
    cout << name << ":" << setw(6);
    for (int value : v)
        cout << value << " ";
    cout << endl;
}

void printVector(vector<vector<int>> v, string name)
{
    cout << name << ":" << endl;
    for (vector<int> row : v)
    {
        for (int value : row)
            cout << value << " ";
        cout << endl;
    }
    cout << endl;
}
